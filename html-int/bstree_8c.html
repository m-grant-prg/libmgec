<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MGE General C Library - Full Internal Documentation: src/prg/c/src/libmgec/listsandsorts/bstree.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MGE General C Library - Full Internal Documentation
   &#160;<span id="projectnumber">v1.8.4</span>
   </div>
   <div id="projectbrief">Library of general C functions.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('bstree_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bstree.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Builds, searches and releases a binary search tree.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="listsandsorts_2internal_8h_source.html">internal.h</a>&quot;</code><br />
<code>#include &lt;<a class="el" href="mge-bstree_8h_source.html">libmgec/mge-bstree.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="mge-errno_8h_source.html">libmgec/mge-errno.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bstree.c:</div>
<div class="dyncontent">
<div class="center"><img src="bstree_8c__incl.png" border="0" usemap="#asrc_2prg_2c_2src_2libmgec_2listsandsorts_2bstree_8c" alt=""/></div>
<map name="asrc_2prg_2c_2src_2libmgec_2listsandsorts_2bstree_8c" id="asrc_2prg_2c_2src_2libmgec_2listsandsorts_2bstree_8c">
<area shape="rect" title="Builds, searches and releases a binary search tree." alt="" coords="237,5,402,47"/>
<area shape="rect" title=" " alt="" coords="5,95,73,121"/>
<area shape="rect" title=" " alt="" coords="98,95,165,121"/>
<area shape="rect" title=" " alt="" coords="189,95,260,121"/>
<area shape="rect" title=" " alt="" coords="284,95,355,121"/>
<area shape="rect" href="listsandsorts_2internal_8h.html" title="Non&#45;public header file for binary search trees in the libmgec shared library." alt="" coords="379,95,463,121"/>
<area shape="rect" href="mge-bstree_8h.html" title="Binary search tree header file." alt="" coords="418,169,583,196"/>
<area shape="rect" href="mge-errno_8h.html" title="Details for mge_errno system." alt="" coords="541,95,700,121"/>
<area shape="rect" href="mge-portability_8h.html" title="Header file to ease portability." alt="" coords="406,244,595,271"/>
<area shape="rect" title=" " alt="" coords="301,244,375,271"/>
<area shape="rect" title=" " alt="" coords="658,169,754,196"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a11e4ed12cd1b235985f1fc426f4fa157"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a11e4ed12cd1b235985f1fc426f4fa157">add_node</a> (struct <a class="el" href="structbstreenode.html">bstreenode</a> *currentnode, const void *object, size_t objsize, struct <a class="el" href="structbstree.html">bstree</a> *tree)</td></tr>
<tr class="memdesc:a11e4ed12cd1b235985f1fc426f4fa157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a binary search tree node with data of 'object' and using object comparison function of 'comp'.  <a href="bstree_8c.html#a11e4ed12cd1b235985f1fc426f4fa157">More...</a><br /></td></tr>
<tr class="separator:a11e4ed12cd1b235985f1fc426f4fa157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af091240b9d0a55b13fb9600a13cda11d"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#af091240b9d0a55b13fb9600a13cda11d">find_node</a> (const struct <a class="el" href="structbstreenode.html">bstreenode</a> *currentnode, const void *searchobj, int(*comp)(const void *, const void *))</td></tr>
<tr class="memdesc:af091240b9d0a55b13fb9600a13cda11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find exact object match.  <a href="bstree_8c.html#af091240b9d0a55b13fb9600a13cda11d">More...</a><br /></td></tr>
<tr class="separator:af091240b9d0a55b13fb9600a13cda11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dccb5e0dd54fd2d7c3bcbd7ac578a98"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a2dccb5e0dd54fd2d7c3bcbd7ac578a98">get_counter_node</a> (const struct <a class="el" href="structbstreenode.html">bstreenode</a> *currentnode, const void *searchobj, int(*comp)(const void *, const void *))</td></tr>
<tr class="memdesc:a2dccb5e0dd54fd2d7c3bcbd7ac578a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find exact object match.  <a href="bstree_8c.html#a2dccb5e0dd54fd2d7c3bcbd7ac578a98">More...</a><br /></td></tr>
<tr class="separator:a2dccb5e0dd54fd2d7c3bcbd7ac578a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0188c44186fe0c74bdb8e8d76320a391"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a0188c44186fe0c74bdb8e8d76320a391">find_next_node</a> (const struct <a class="el" href="structbstreenode.html">bstreenode</a> *currentnode, const void *searchobj, int(*comp)(const void *, const void *))</td></tr>
<tr class="memdesc:a0188c44186fe0c74bdb8e8d76320a391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and return the next object.  <a href="bstree_8c.html#a0188c44186fe0c74bdb8e8d76320a391">More...</a><br /></td></tr>
<tr class="separator:a0188c44186fe0c74bdb8e8d76320a391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0fe5c8fcf56007f437272a5d2964b2"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#aba0fe5c8fcf56007f437272a5d2964b2">find_prev_node</a> (const struct <a class="el" href="structbstreenode.html">bstreenode</a> *currentnode, const void *searchobj, int(*comp)(const void *, const void *))</td></tr>
<tr class="memdesc:aba0fe5c8fcf56007f437272a5d2964b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and return the previous object.  <a href="bstree_8c.html#aba0fe5c8fcf56007f437272a5d2964b2">More...</a><br /></td></tr>
<tr class="separator:aba0fe5c8fcf56007f437272a5d2964b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9caaf6a9e36ab5af07e9c46b632a43c0"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a9caaf6a9e36ab5af07e9c46b632a43c0">upd_node</a> (struct <a class="el" href="structbstreenode.html">bstreenode</a> *currentnode, const void *updobj, size_t objsize, int(*comp)(const void *, const void *))</td></tr>
<tr class="memdesc:a9caaf6a9e36ab5af07e9c46b632a43c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the object.  <a href="bstree_8c.html#a9caaf6a9e36ab5af07e9c46b632a43c0">More...</a><br /></td></tr>
<tr class="separator:a9caaf6a9e36ab5af07e9c46b632a43c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28df34dcb13229f2c86e770859b3337"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#ad28df34dcb13229f2c86e770859b3337">del_node</a> (struct <a class="el" href="structbstreenode.html">bstreenode</a> *currentnode, const void *searchobj, struct <a class="el" href="structbstree.html">bstree</a> *tree)</td></tr>
<tr class="memdesc:ad28df34dcb13229f2c86e770859b3337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete node.  <a href="bstree_8c.html#ad28df34dcb13229f2c86e770859b3337">More...</a><br /></td></tr>
<tr class="separator:ad28df34dcb13229f2c86e770859b3337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21788f61b527b070296483cdf22b253"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#ad21788f61b527b070296483cdf22b253">free_bstree</a> (struct <a class="el" href="structbstreenode.html">bstreenode</a> *currentnode)</td></tr>
<tr class="memdesc:ad21788f61b527b070296483cdf22b253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated to the bstree.  <a href="bstree_8c.html#ad21788f61b527b070296483cdf22b253">More...</a><br /></td></tr>
<tr class="separator:ad21788f61b527b070296483cdf22b253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b05bf3e1913d9018a39ac1c137f8b7"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#ad6b05bf3e1913d9018a39ac1c137f8b7">free_bst_node</a> (struct <a class="el" href="structbstreenode.html">bstreenode</a> *currentnode)</td></tr>
<tr class="memdesc:ad6b05bf3e1913d9018a39ac1c137f8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated to the node.  <a href="bstree_8c.html#ad6b05bf3e1913d9018a39ac1c137f8b7">More...</a><br /></td></tr>
<tr class="separator:ad6b05bf3e1913d9018a39ac1c137f8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7393e2c1af4a4b374977b309f799a201"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a7393e2c1af4a4b374977b309f799a201">find_next_node_trace</a> (const struct <a class="el" href="structbstreenode.html">bstreenode</a> *currentnode, struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a> *searchobj, int(*comp)(const void *, const void *))</td></tr>
<tr class="memdesc:a7393e2c1af4a4b374977b309f799a201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and return the next object and it's coordinates.  <a href="bstree_8c.html#a7393e2c1af4a4b374977b309f799a201">More...</a><br /></td></tr>
<tr class="separator:a7393e2c1af4a4b374977b309f799a201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99224174bcdfc8d39c7a3aa23d0acf5e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a99224174bcdfc8d39c7a3aa23d0acf5e">cre_bst</a> (int unique, int(*comp)(const void *, const void *))</td></tr>
<tr class="memdesc:a99224174bcdfc8d39c7a3aa23d0acf5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a binary search tree.  <a href="bstree_8c.html#a99224174bcdfc8d39c7a3aa23d0acf5e">More...</a><br /></td></tr>
<tr class="separator:a99224174bcdfc8d39c7a3aa23d0acf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0ae362f96ff51f60a04ae54560501f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a8a0ae362f96ff51f60a04ae54560501f">add_bst_node</a> (struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *object, size_t objsize)</td></tr>
<tr class="memdesc:a8a0ae362f96ff51f60a04ae54560501f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to a binary search tree.  <a href="bstree_8c.html#a8a0ae362f96ff51f60a04ae54560501f">More...</a><br /></td></tr>
<tr class="separator:a8a0ae362f96ff51f60a04ae54560501f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486be2ec0744640dcabe6323304db158"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a486be2ec0744640dcabe6323304db158">find_bst_node</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *searchobj)</td></tr>
<tr class="memdesc:a486be2ec0744640dcabe6323304db158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an exact object match.  <a href="bstree_8c.html#a486be2ec0744640dcabe6323304db158">More...</a><br /></td></tr>
<tr class="separator:a486be2ec0744640dcabe6323304db158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2ac28c952d279d698a012a372ac99e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a5d2ac28c952d279d698a012a372ac99e">get_counter_bst_node</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *searchobj)</td></tr>
<tr class="memdesc:a5d2ac28c952d279d698a012a372ac99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the counter for a node.  <a href="bstree_8c.html#a5d2ac28c952d279d698a012a372ac99e">More...</a><br /></td></tr>
<tr class="separator:a5d2ac28c952d279d698a012a372ac99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5f206d0d1a1681835b3f7bfbf0f431"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a1b5f206d0d1a1681835b3f7bfbf0f431">find_next_bst_node</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *searchobj)</td></tr>
<tr class="memdesc:a1b5f206d0d1a1681835b3f7bfbf0f431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next node.  <a href="bstree_8c.html#a1b5f206d0d1a1681835b3f7bfbf0f431">More...</a><br /></td></tr>
<tr class="separator:a1b5f206d0d1a1681835b3f7bfbf0f431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d963b0f0274dfe90837f4a7779eed1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#ac4d963b0f0274dfe90837f4a7779eed1">find_prev_bst_node</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *searchobj)</td></tr>
<tr class="memdesc:ac4d963b0f0274dfe90837f4a7779eed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the previous node.  <a href="bstree_8c.html#ac4d963b0f0274dfe90837f4a7779eed1">More...</a><br /></td></tr>
<tr class="separator:ac4d963b0f0274dfe90837f4a7779eed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012b8ae70029c72eaaf81a0765c0e49a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a012b8ae70029c72eaaf81a0765c0e49a">upd_bst_node</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *updobj, size_t objsize)</td></tr>
<tr class="memdesc:a012b8ae70029c72eaaf81a0765c0e49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a node's object.  <a href="bstree_8c.html#a012b8ae70029c72eaaf81a0765c0e49a">More...</a><br /></td></tr>
<tr class="separator:a012b8ae70029c72eaaf81a0765c0e49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a009d4d10be3cfaeef8cd0933a8993"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a54a009d4d10be3cfaeef8cd0933a8993">del_bst_node</a> (struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *searchobj)</td></tr>
<tr class="memdesc:a54a009d4d10be3cfaeef8cd0933a8993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a node.  <a href="bstree_8c.html#a54a009d4d10be3cfaeef8cd0933a8993">More...</a><br /></td></tr>
<tr class="separator:a54a009d4d10be3cfaeef8cd0933a8993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef02c9547b4c46ca56ddf7fa79046dda"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#aef02c9547b4c46ca56ddf7fa79046dda">del_bst</a> (struct <a class="el" href="structbstree.html">bstree</a> *tree)</td></tr>
<tr class="memdesc:aef02c9547b4c46ca56ddf7fa79046dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a bst.  <a href="bstree_8c.html#aef02c9547b4c46ca56ddf7fa79046dda">More...</a><br /></td></tr>
<tr class="separator:aef02c9547b4c46ca56ddf7fa79046dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e767bbbe06c82e3774caaf88f4ceeec"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a1e767bbbe06c82e3774caaf88f4ceeec">find_next_bst_node_trace</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a> *searchobj)</td></tr>
<tr class="memdesc:a1e767bbbe06c82e3774caaf88f4ceeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and return the next object and it's coordinates in the bst 'tree'.  <a href="bstree_8c.html#a1e767bbbe06c82e3774caaf88f4ceeec">More...</a><br /></td></tr>
<tr class="separator:a1e767bbbe06c82e3774caaf88f4ceeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Builds, searches and releases a binary search tree. </p>
<p>This implementation supports object independence by using a comparison function which conforms to the prototype:-<br  />
 </p><blockquote class="doxtable">
<p>int (*comp)(const void *, const void *) </p>
</blockquote>
<p>and which returns the value of:-<br  />
</p><blockquote class="doxtable">
<p>&lt; 0 if the first parameter is less than the second,<br  />
0 if they are equal and<br  />
&gt; 0 if the first is greater than the second.<br  />
</p>
</blockquote>
<p><em>In fact, the same as strcmp().</em></p>
<dl class="section author"><dt>Author</dt><dd>Copyright (C) 2015-2023 Mark Grant</dd></dl>
<p>Released under the GPLv3 only.<br  />
SPDX-License-Identifier: GPL-3.0-only</p>
<dl class="section version"><dt>Version</dt><dd><em>v1.2.0 ==== 02/11/2023</em> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8a0ae362f96ff51f60a04ae54560501f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0ae362f96ff51f60a04ae54560501f">&#9670;&nbsp;</a></span>add_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbstree.html">bstree</a>* add_bst_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>objsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a node to a binary search tree. </p>
<p>Attempts to add a node to a binary search tree. If the node exists and unique is true for this tree, an error is generated, if unique is false then the node counter is incremented. On error mge_errno is set and NULL is returned but the bst will remain as before the failed add. Hence it is important to preserve the pointer to the tree across this function.<br  />
</p><pre class="fragment">tmp_tree = add_bst_node(tree, object, objsize);
if (tmp_tree == NULL) {
        ... error handling
    return error;
}
tree = tmp_tree;
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree to add to. </td></tr>
    <tr><td class="paramname">object</td><td>The object to add. </td></tr>
    <tr><td class="paramname">objsize</td><td>The size of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the binary tree 'tree' or NULL on error. </dd></dl>

</div>
</div>
<a id="a11e4ed12cd1b235985f1fc426f4fa157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e4ed12cd1b235985f1fc426f4fa157">&#9670;&nbsp;</a></span>add_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structbstreenode.html">bstreenode</a> * add_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td>
          <td class="paramname"><em>currentnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>objsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a binary search tree node with data of 'object' and using object comparison function of 'comp'. </p>
<p>Node uniqueness is defined by the unique parameter. Errors - mge_errno will be set as required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentnode</td><td>- On call from user code is a pointer to the root node or NULL if tree not yet started. Within the function and in recursion it is the node being processed. </td></tr>
    <tr><td class="paramname">object</td><td>The object to add. </td></tr>
    <tr><td class="paramname">objsize</td><td>The size of the object. </td></tr>
    <tr><td class="paramname">tree</td><td>The tree to add to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns NULL on error. On exit to user code a pointer to the root node. Within the function it is a pointer to the node being processed. On error the bst will remain as before the failed add. Hence it is important to preserve the pointer to the root node across this function. </dd></dl>

</div>
</div>
<a id="a99224174bcdfc8d39c7a3aa23d0acf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99224174bcdfc8d39c7a3aa23d0acf5e">&#9670;&nbsp;</a></span>cre_bst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbstree.html">bstree</a>* cre_bst </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a binary search tree. </p>
<p>Creates a new binary search tree object which must eventually be freed by <a class="el" href="bstree_8c.html#aef02c9547b4c46ca56ddf7fa79046dda" title="Delete a bst.">del_bst()</a>. On error mge_errno is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unique</td><td>If set to true (1) then attempting to add a second identical node will generate an error. If set to false (0) then adding identical nodes increments the node counter. </td></tr>
    <tr><td class="paramname">comp</td><td>A pointer to the comparison function to be used. This implementation supports object independence by using a comparison function which conforms to the prototype:-<br  />
<blockquote class="doxtable">
<p>int (*comp)(const void *, const void *) </p>
</blockquote>
and which returns the value of:-<br  />
<blockquote class="doxtable">
<p>&lt; 0 if the first parameter is less than the second,<br  />
0 if they are equal and<br  />
&gt; 0 if the first is greater than the second.<br  />
</p>
</blockquote>
<em>In fact, the same as strcmp().</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created binary search tree or NULL on error. </dd></dl>

</div>
</div>
<a id="aef02c9547b4c46ca56ddf7fa79046dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef02c9547b4c46ca56ddf7fa79046dda">&#9670;&nbsp;</a></span>del_bst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbstree.html">bstree</a>* del_bst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a bst. </p>
<p>Delete a binary search tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL </dd></dl>

</div>
</div>
<a id="a54a009d4d10be3cfaeef8cd0933a8993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a009d4d10be3cfaeef8cd0933a8993">&#9670;&nbsp;</a></span>del_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbstree.html">bstree</a>* del_bst_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a node. </p>
<p>Delete a node in the bst 'tree'. Re-links any children. If the node counter is &gt; 1 then duplicates are allowed and the counter is decremented instead of deleting the node. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated bst, or, NULL on error. </dd></dl>

</div>
</div>
<a id="ad28df34dcb13229f2c86e770859b3337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28df34dcb13229f2c86e770859b3337">&#9670;&nbsp;</a></span>del_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structbstreenode.html">bstreenode</a> * del_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td>
          <td class="paramname"><em>currentnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete node. </p>
<p>Re-links any children. If the node counter is &gt; 1 then duplicates are allowed and the counter is decremented instead of deleting the node. Errors - mge_errno will be 0 on sucess or set as required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentnode</td><td>- On invocation from user code this is the root node. </td></tr>
    <tr><td class="paramname">searchobj</td><td>- The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns to the calling function a pointer to the root node, or, NULL if it was the last remaining node which was deleted. Also returns NULL on some errors. </dd></dl>

</div>
</div>
<a id="a486be2ec0744640dcabe6323304db158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486be2ec0744640dcabe6323304db158">&#9670;&nbsp;</a></span>find_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* find_bst_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an exact object match. </p>
<p>Find an exact object match in the bst 'tree'. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the object found in the node, (i.e. the fully populated object), or, NULL if not found or an error was encountered. </dd></dl>

</div>
</div>
<a id="a1b5f206d0d1a1681835b3f7bfbf0f431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5f206d0d1a1681835b3f7bfbf0f431">&#9670;&nbsp;</a></span>find_next_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* find_next_bst_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the next node. </p>
<p>Find the next node in the bst and return the object. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next object found in the tree, (i.e. a fully populated object), or, NULL if not found or an error was encountered. </dd></dl>

</div>
</div>
<a id="a1e767bbbe06c82e3774caaf88f4ceeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e767bbbe06c82e3774caaf88f4ceeec">&#9670;&nbsp;</a></span>find_next_bst_node_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a>* find_next_bst_node_trace </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a> *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and return the next object and it's coordinates in the bst 'tree'. </p>
<p>This is only really useful for testing purposes where this function can be used to verify the tree coordinates of nodes. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next coordinate object found in the tree, (i.e. a fully populated object), or, the actual node object will be NULL if not found. Returns NULL on error. </dd></dl>

</div>
</div>
<a id="a0188c44186fe0c74bdb8e8d76320a391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0188c44186fe0c74bdb8e8d76320a391">&#9670;&nbsp;</a></span>find_next_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * find_next_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td>
          <td class="paramname"><em>currentnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and return the next object. </p>
<p>Errors - mge_errno will be set as required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentnode</td><td>- On invocation from user code this is the root node. </td></tr>
    <tr><td class="paramname">searchobj</td><td>- The object to start from. It does not need to be a fully populated object nor does the object need to exist. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
    <tr><td class="paramname">comp</td><td>A pointer to the comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the next object found in the tree, (i.e. a fully populated object), or, NULL if not found or an error was encountered. </dd></dl>

</div>
</div>
<a id="a7393e2c1af4a4b374977b309f799a201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7393e2c1af4a4b374977b309f799a201">&#9670;&nbsp;</a></span>find_next_node_trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a> * find_next_node_trace </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td>
          <td class="paramname"><em>currentnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a> *&#160;</td>
          <td class="paramname"><em>searchobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and return the next object and it's coordinates. </p>
<p>This is only really useful for testing purposes where this function can be used to verify the tree coordinates of nodes. Errors - NULL will be returned and mge_errno will be set as required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentnode</td><td>- On invocation from user code this is the root node. </td></tr>
    <tr><td class="paramname">searchobj</td><td>- The trace object to start from. It does not need to be a fully populated object nor does the object need to exist. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
    <tr><td class="paramname">comp</td><td>A pointer to the comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the next coordinate object found in the tree, (i.e. a fully populated object), or, the actual node object will be NULL if not found. Returns NULL on error. </dd></dl>

</div>
</div>
<a id="af091240b9d0a55b13fb9600a13cda11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af091240b9d0a55b13fb9600a13cda11d">&#9670;&nbsp;</a></span>find_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * find_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td>
          <td class="paramname"><em>currentnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find exact object match. </p>
<p>Errors - mge_errno will be set as required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentnode</td><td>- On invocation from user code this is the root node. </td></tr>
    <tr><td class="paramname">searchobj</td><td>- The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
    <tr><td class="paramname">comp</td><td>A pointer to the comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the object found in the node, (i.e. the fully populated object), or, NULL if not found or an error was encountered. </dd></dl>

</div>
</div>
<a id="ac4d963b0f0274dfe90837f4a7779eed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d963b0f0274dfe90837f4a7779eed1">&#9670;&nbsp;</a></span>find_prev_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* find_prev_bst_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the previous node. </p>
<p>Find and return the object attached to the previous node in the bst 'tree'. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the preceding object in the tree, (i.e. a fully populated object), or, NULL if not found or an error was encountered. </dd></dl>

</div>
</div>
<a id="aba0fe5c8fcf56007f437272a5d2964b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0fe5c8fcf56007f437272a5d2964b2">&#9670;&nbsp;</a></span>find_prev_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * find_prev_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td>
          <td class="paramname"><em>currentnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and return the previous object. </p>
<p>Errors - mge_errno will be set as required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentnode</td><td>- On invocation from user code this is the root node. </td></tr>
    <tr><td class="paramname">searchobj</td><td>- The object to start from. It does not need to be a fully populated object nor does the object need to exist. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
    <tr><td class="paramname">comp</td><td>A pointer to the comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the preceding object in the tree, (i.e. a fully populated object), or, NULL if not found or an error was encountered. </dd></dl>

</div>
</div>
<a id="ad6b05bf3e1913d9018a39ac1c137f8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b05bf3e1913d9018a39ac1c137f8b7">&#9670;&nbsp;</a></span>free_bst_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structbstreenode.html">bstreenode</a> * free_bst_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td>
          <td class="paramname"><em>currentnode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free memory allocated to the node. </p>
<p>(Both node and object). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentnode</td><td>The node to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL </dd></dl>

</div>
</div>
<a id="ad21788f61b527b070296483cdf22b253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21788f61b527b070296483cdf22b253">&#9670;&nbsp;</a></span>free_bstree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structbstreenode.html">bstreenode</a> * free_bstree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td>
          <td class="paramname"><em>currentnode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free memory allocated to the bstree. </p>
<p>Walks the tree deleting nodes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentnode</td><td>The root node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL </dd></dl>

</div>
</div>
<a id="a5d2ac28c952d279d698a012a372ac99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2ac28c952d279d698a012a372ac99e">&#9670;&nbsp;</a></span>get_counter_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_counter_bst_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the counter for a node. </p>
<p>Get the node counter for an object in the bst 'tree'. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times <a class="el" href="bstree_8c.html#a8a0ae362f96ff51f60a04ae54560501f" title="Add a node to a binary search tree.">add_bst_node()</a> was asked to create this node, or, 0 if not found, or, -mge_errno on error. </dd></dl>

</div>
</div>
<a id="a2dccb5e0dd54fd2d7c3bcbd7ac578a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dccb5e0dd54fd2d7c3bcbd7ac578a98">&#9670;&nbsp;</a></span>get_counter_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int get_counter_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td>
          <td class="paramname"><em>currentnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find exact object match. </p>
<p>Returns the number of matches. Errors - mge_errno will be set as required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentnode</td><td>- On invocation from user code this is the root node. </td></tr>
    <tr><td class="paramname">searchobj</td><td>- The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
    <tr><td class="paramname">comp</td><td>A pointer to the comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of times <a class="el" href="bstree_8c.html#a8a0ae362f96ff51f60a04ae54560501f" title="Add a node to a binary search tree.">add_bst_node()</a> was asked to create this node, or, 0 if not found, or, -mge_errno on error. </dd></dl>

</div>
</div>
<a id="a012b8ae70029c72eaaf81a0765c0e49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012b8ae70029c72eaaf81a0765c0e49a">&#9670;&nbsp;</a></span>upd_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* upd_bst_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>updobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>objsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a node's object. </p>
<p>Update the object in a node in the bst 'tree'. (This only makes sense if the object is carrying a payload.) On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">updobj</td><td>The object to update. The node is found and the existing object is replaced with the new object. </td></tr>
    <tr><td class="paramname">objsize</td><td>The size of the new object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new object, or, NULL if not found or error. </dd></dl>

</div>
</div>
<a id="a9caaf6a9e36ab5af07e9c46b632a43c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9caaf6a9e36ab5af07e9c46b632a43c0">&#9670;&nbsp;</a></span>upd_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * upd_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstreenode.html">bstreenode</a> *&#160;</td>
          <td class="paramname"><em>currentnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>updobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>objsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the object. </p>
<p>(This only makes sense if the object is carrying a payload.) Errors - mge_errno will be set as required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentnode</td><td>- On invocation from user code this is the root node. </td></tr>
    <tr><td class="paramname">updobj</td><td>- The object to update. The node is found and the existing object is replaced with the new object. </td></tr>
    <tr><td class="paramname">objsize</td><td>The size of the new object. </td></tr>
    <tr><td class="paramname">comp</td><td>A pointer to the comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the new object, or, NULL if not found or error. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_a1986ada3285f0a0ebcb94921d9f60ef.html">prg</a></li><li class="navelem"><a class="el" href="dir_088b4e4436e06887f3fa9c5a3af9d85c.html">c</a></li><li class="navelem"><a class="el" href="dir_29196a9fd547b021dd2fe1aed517e98d.html">src</a></li><li class="navelem"><a class="el" href="dir_52a6e28feaf66fe27205aa2ea28c0372.html">libmgec</a></li><li class="navelem"><a class="el" href="dir_936dec95a50173736617377efb8d602b.html">listsandsorts</a></li><li class="navelem"><a class="el" href="bstree_8c.html">bstree.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
