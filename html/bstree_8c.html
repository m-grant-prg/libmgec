<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MGE General C Library - API Documentation: src/prg/c/src/libmgec/listsandsorts/bstree.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MGE General C Library - API Documentation
   &#160;<span id="projectnumber">v1.6.5+rc1</span>
   </div>
   <div id="projectbrief">Library of general C functions.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('bstree_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bstree.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;bstree-internal.h&quot;</code><br />
<code>#include &lt;<a class="el" href="bstree_8h_source.html">bstree.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="mge-errno_8h_source.html">mge-errno.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bstree.c:</div>
<div class="dyncontent">
<div class="center"><img src="bstree_8c__incl.png" border="0" usemap="#src_2prg_2c_2src_2libmgec_2listsandsorts_2bstree_8c" alt=""/></div>
<map name="src_2prg_2c_2src_2libmgec_2listsandsorts_2bstree_8c" id="src_2prg_2c_2src_2libmgec_2listsandsorts_2bstree_8c">
<area shape="rect" title=" " alt="" coords="237,5,402,47"/>
<area shape="rect" title=" " alt="" coords="5,95,73,121"/>
<area shape="rect" title=" " alt="" coords="98,95,165,121"/>
<area shape="rect" title=" " alt="" coords="189,95,260,121"/>
<area shape="rect" title=" " alt="" coords="284,95,355,121"/>
<area shape="rect" title=" " alt="" coords="379,95,510,121"/>
<area shape="rect" href="bstree_8h.html" title=" " alt="" coords="534,95,609,121"/>
<area shape="rect" href="mge-errno_8h.html" title=" " alt="" coords="633,95,736,121"/>
<area shape="rect" href="portability_8h.html" title=" " alt="" coords="522,169,621,196"/>
<area shape="rect" title=" " alt="" coords="645,169,741,196"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a99224174bcdfc8d39c7a3aa23d0acf5e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a99224174bcdfc8d39c7a3aa23d0acf5e">cre_bst</a> (int unique, int(*comp)(const void *, const void *))</td></tr>
<tr class="memdesc:a99224174bcdfc8d39c7a3aa23d0acf5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a binary search tree.  <a href="bstree_8c.html#a99224174bcdfc8d39c7a3aa23d0acf5e">More...</a><br /></td></tr>
<tr class="separator:a99224174bcdfc8d39c7a3aa23d0acf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0ae362f96ff51f60a04ae54560501f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a8a0ae362f96ff51f60a04ae54560501f">add_bst_node</a> (struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *object, size_t objsize)</td></tr>
<tr class="memdesc:a8a0ae362f96ff51f60a04ae54560501f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to a binary search tree.  <a href="bstree_8c.html#a8a0ae362f96ff51f60a04ae54560501f">More...</a><br /></td></tr>
<tr class="separator:a8a0ae362f96ff51f60a04ae54560501f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486be2ec0744640dcabe6323304db158"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a486be2ec0744640dcabe6323304db158">find_bst_node</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *searchobj)</td></tr>
<tr class="memdesc:a486be2ec0744640dcabe6323304db158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an exact object match.  <a href="bstree_8c.html#a486be2ec0744640dcabe6323304db158">More...</a><br /></td></tr>
<tr class="separator:a486be2ec0744640dcabe6323304db158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2ac28c952d279d698a012a372ac99e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a5d2ac28c952d279d698a012a372ac99e">get_counter_bst_node</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *searchobj)</td></tr>
<tr class="memdesc:a5d2ac28c952d279d698a012a372ac99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the counter for a node.  <a href="bstree_8c.html#a5d2ac28c952d279d698a012a372ac99e">More...</a><br /></td></tr>
<tr class="separator:a5d2ac28c952d279d698a012a372ac99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5f206d0d1a1681835b3f7bfbf0f431"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a1b5f206d0d1a1681835b3f7bfbf0f431">find_next_bst_node</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *searchobj)</td></tr>
<tr class="memdesc:a1b5f206d0d1a1681835b3f7bfbf0f431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next node.  <a href="bstree_8c.html#a1b5f206d0d1a1681835b3f7bfbf0f431">More...</a><br /></td></tr>
<tr class="separator:a1b5f206d0d1a1681835b3f7bfbf0f431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d963b0f0274dfe90837f4a7779eed1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#ac4d963b0f0274dfe90837f4a7779eed1">find_prev_bst_node</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *searchobj)</td></tr>
<tr class="memdesc:ac4d963b0f0274dfe90837f4a7779eed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the previous node.  <a href="bstree_8c.html#ac4d963b0f0274dfe90837f4a7779eed1">More...</a><br /></td></tr>
<tr class="separator:ac4d963b0f0274dfe90837f4a7779eed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012b8ae70029c72eaaf81a0765c0e49a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a012b8ae70029c72eaaf81a0765c0e49a">upd_bst_node</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *updobj, size_t objsize)</td></tr>
<tr class="memdesc:a012b8ae70029c72eaaf81a0765c0e49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a node's object.  <a href="bstree_8c.html#a012b8ae70029c72eaaf81a0765c0e49a">More...</a><br /></td></tr>
<tr class="separator:a012b8ae70029c72eaaf81a0765c0e49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a009d4d10be3cfaeef8cd0933a8993"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a54a009d4d10be3cfaeef8cd0933a8993">del_bst_node</a> (struct <a class="el" href="structbstree.html">bstree</a> *tree, const void *searchobj)</td></tr>
<tr class="memdesc:a54a009d4d10be3cfaeef8cd0933a8993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a node.  <a href="bstree_8c.html#a54a009d4d10be3cfaeef8cd0933a8993">More...</a><br /></td></tr>
<tr class="separator:a54a009d4d10be3cfaeef8cd0933a8993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef02c9547b4c46ca56ddf7fa79046dda"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#aef02c9547b4c46ca56ddf7fa79046dda">del_bst</a> (struct <a class="el" href="structbstree.html">bstree</a> *tree)</td></tr>
<tr class="memdesc:aef02c9547b4c46ca56ddf7fa79046dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a bst.  <a href="bstree_8c.html#aef02c9547b4c46ca56ddf7fa79046dda">More...</a><br /></td></tr>
<tr class="separator:aef02c9547b4c46ca56ddf7fa79046dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e767bbbe06c82e3774caaf88f4ceeec"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstree_8c.html#a1e767bbbe06c82e3774caaf88f4ceeec">find_next_bst_node_trace</a> (const struct <a class="el" href="structbstree.html">bstree</a> *tree, struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a> *searchobj)</td></tr>
<tr class="memdesc:a1e767bbbe06c82e3774caaf88f4ceeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and return the next object and it's coordinates in the bst 'tree'.  <a href="bstree_8c.html#a1e767bbbe06c82e3774caaf88f4ceeec">More...</a><br /></td></tr>
<tr class="separator:a1e767bbbe06c82e3774caaf88f4ceeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Builds, searches and releases a binary search tree.</p>
<p>This implementation supports object independence by using a comparison function which conforms to the prototype:-<br  />
 </p><blockquote class="doxtable">
<p>int (*comp)(const void *, const void *) </p>
</blockquote>
<p>and which returns the value of:-<br  />
</p><blockquote class="doxtable">
<p>&lt; 0 if the first parameter is less than the second,<br  />
0 if they are equal and<br  />
&gt; 0 if the first is greater than the second.<br  />
</p>
</blockquote>
<p><em>In fact, the same as strcmp().</em></p>
<dl class="section author"><dt>Author</dt><dd>Copyright (C) 2015-2021 Mark Grant</dd></dl>
<p>Released under the GPLv3 only.<br  />
SPDX-License-Identifier: GPL-3.0-only</p>
<dl class="section version"><dt>Version</dt><dd><em>v1.1.10 ==== 03/12/2021</em> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8a0ae362f96ff51f60a04ae54560501f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0ae362f96ff51f60a04ae54560501f">&#9670;&nbsp;</a></span>add_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbstree.html">bstree</a>* add_bst_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>objsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a node to a binary search tree. </p>
<p>Attempts to add a node to a binary search tree. If the node exists and unique is true for this tree, an error is generated, if unique is false then the node counter is incremented. On error mge_errno is set and NULL is returned but the bst will remain as before the failed add. Hence it is important to preserve the pointer to the tree across this function.<br  />
</p><pre class="fragment">tmp_tree = add_bst_node(tree, object, objsize);
if (tmp_tree == NULL) {
        ... error handling
    return error;
}
tree = tmp_tree;
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree to add to. </td></tr>
    <tr><td class="paramname">object</td><td>The object to add. </td></tr>
    <tr><td class="paramname">objsize</td><td>The size of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the binary tree 'tree' or NULL on error. </dd></dl>

</div>
</div>
<a id="a99224174bcdfc8d39c7a3aa23d0acf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99224174bcdfc8d39c7a3aa23d0acf5e">&#9670;&nbsp;</a></span>cre_bst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbstree.html">bstree</a>* cre_bst </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a binary search tree. </p>
<p>Creates a new binary search tree object which must eventually be freed by <a class="el" href="bstree_8c.html#aef02c9547b4c46ca56ddf7fa79046dda" title="Delete a bst.">del_bst()</a>. On error mge_errno is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unique</td><td>If set to true (1) then attempting to add a second identical node will generate an error. If set to false (0) then adding identical nodes increments the node counter. </td></tr>
    <tr><td class="paramname">comp</td><td>A pointer to the comparison function to be used. This implementation supports object independence by using a comparison function which conforms to the prototype:-<br  />
<blockquote class="doxtable">
<p>int (*comp)(const void *, const void *) </p>
</blockquote>
and which returns the value of:-<br  />
<blockquote class="doxtable">
<p>&lt; 0 if the first parameter is less than the second,<br  />
0 if they are equal and<br  />
&gt; 0 if the first is greater than the second.<br  />
</p>
</blockquote>
<em>In fact, the same as strcmp().</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created binary search tree or NULL on error. </dd></dl>

</div>
</div>
<a id="aef02c9547b4c46ca56ddf7fa79046dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef02c9547b4c46ca56ddf7fa79046dda">&#9670;&nbsp;</a></span>del_bst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbstree.html">bstree</a>* del_bst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a bst. </p>
<p>Delete a binary search tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL </dd></dl>

</div>
</div>
<a id="a54a009d4d10be3cfaeef8cd0933a8993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a009d4d10be3cfaeef8cd0933a8993">&#9670;&nbsp;</a></span>del_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbstree.html">bstree</a>* del_bst_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a node. </p>
<p>Delete a node in the bst 'tree'. Re-links any children. If the node counter is &gt; 1 then duplicates are allowed and the counter is decremented instead of deleting the node. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated bst, or, NULL on error. </dd></dl>

</div>
</div>
<a id="a486be2ec0744640dcabe6323304db158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486be2ec0744640dcabe6323304db158">&#9670;&nbsp;</a></span>find_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* find_bst_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an exact object match. </p>
<p>Find an exact object match in the bst 'tree'. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the object found in the node, (i.e. the fully populated object), or, NULL if not found or an error was encountered. </dd></dl>

</div>
</div>
<a id="a1b5f206d0d1a1681835b3f7bfbf0f431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5f206d0d1a1681835b3f7bfbf0f431">&#9670;&nbsp;</a></span>find_next_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* find_next_bst_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the next node. </p>
<p>Find the next node in the bst and return the object. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next object found in the tree, (i.e. a fully populated object), or, NULL if not found or an error was encountered. </dd></dl>

</div>
</div>
<a id="a1e767bbbe06c82e3774caaf88f4ceeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e767bbbe06c82e3774caaf88f4ceeec">&#9670;&nbsp;</a></span>find_next_bst_node_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a>* find_next_bst_node_trace </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbstobjcoord.html">bstobjcoord</a> *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and return the next object and it's coordinates in the bst 'tree'. </p>
<p>This is only really useful for testing purposes where this function can be used to verify the tree coordinates of nodes. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next coordinate object found in the tree, (i.e. a fully populated object), or, the actual node object will be NULL if not found. Returns NULL on error. </dd></dl>

</div>
</div>
<a id="ac4d963b0f0274dfe90837f4a7779eed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d963b0f0274dfe90837f4a7779eed1">&#9670;&nbsp;</a></span>find_prev_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* find_prev_bst_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the previous node. </p>
<p>Find and return the object attached to the previous node in the bst 'tree'. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the preceding object in the tree, (i.e. a fully populated object), or, NULL if not found or an error was encountered. </dd></dl>

</div>
</div>
<a id="a5d2ac28c952d279d698a012a372ac99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2ac28c952d279d698a012a372ac99e">&#9670;&nbsp;</a></span>get_counter_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_counter_bst_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>searchobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the counter for a node. </p>
<p>Get the node counter for an object in the bst 'tree'. On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">searchobj</td><td>The object to find. It does not need to be a fully populated object. It only needs enough information to support the comparison function. E.g. a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times <a class="el" href="bstree_8c.html#a8a0ae362f96ff51f60a04ae54560501f" title="Add a node to a binary search tree.">add_bst_node()</a> was asked to create this node, or, 0 if not found, or, -mge_errno on error. </dd></dl>

</div>
</div>
<a id="a012b8ae70029c72eaaf81a0765c0e49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012b8ae70029c72eaaf81a0765c0e49a">&#9670;&nbsp;</a></span>upd_bst_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* upd_bst_node </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstree.html">bstree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>updobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>objsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a node's object. </p>
<p>Update the object in a node in the bst 'tree'. (This only makes sense if the object is carrying a payload.) On error mge_errno will be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The bst to search. </td></tr>
    <tr><td class="paramname">updobj</td><td>The object to update. The node is found and the existing object is replaced with the new object. </td></tr>
    <tr><td class="paramname">objsize</td><td>The size of the new object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new object, or, NULL if not found or error. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_a1986ada3285f0a0ebcb94921d9f60ef.html">prg</a></li><li class="navelem"><a class="el" href="dir_088b4e4436e06887f3fa9c5a3af9d85c.html">c</a></li><li class="navelem"><a class="el" href="dir_29196a9fd547b021dd2fe1aed517e98d.html">src</a></li><li class="navelem"><a class="el" href="dir_52a6e28feaf66fe27205aa2ea28c0372.html">libmgec</a></li><li class="navelem"><a class="el" href="dir_936dec95a50173736617377efb8d602b.html">listsandsorts</a></li><li class="navelem"><a class="el" href="bstree_8c.html">bstree.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
